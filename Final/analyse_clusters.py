import json
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import statistics
from tabulate import tabulate

from Final import populate_result

# Models whose clusters are to be analysed (to be updated as required)
models = ['dbscan', 'baseline']


def main(pair_list, returns, model):
    analyse_pairs(pair_list, returns, model)


def analyse_pairs(pair_lists, returns, model):

    ''' Analyses the pairs generated by the model per cluster

    :param pair_lists: List of pairs identified by the model in each year
    :param payoffs_per_pair_list: List of payoffs made by each identified pair (separate list for each year)
    :param model: Model in concern
    :return: None
    '''

    # payoffs_per_pair_list: [{group:[(payoffs, start, end, start, end)]}]
    # pair_lists: [{group: [(permno_one, trade_start_one_row, permno_two, trade_start_two_row, mean, std, gamma, sic_one, sic_two)]}]
    with open('/Users/elysiatan/PycharmProjects/thesis/fama_french.json') as json_file:
        groups = json.load(json_file)

    recurring_pairs_dict = {}                # Counts the number of times a particular pair is formed

    for year in range(0, len(pair_lists)):
        print(year)
        pair_list = pair_lists[year]
        payoffs_list = returns[year]

        returns_list = []
        indiv_pairs_payoffs_dict = {}        # Payoffs of individual pairs formed in the year
        indiv_pairs_gamma_dict = {}           # (gamma, Payoffs) of individual pairs formed in the year

        for group in pair_list.keys():
            print(group)
            inter_industry_pairs = []        # List of inter-industry pairs in the cluster
            within_industry_pairs = []       # List of within-industry pairs in the cluster

            inter_industry_pairs_dict = {}   # Splits the inter-indsutry pairs into their respective group pair
            pairs_gamma_dict = {}             # Stores the gamma of chosen pairs separated by (industry1, industry2)
            pairs_payoffs_dict = {}          # Stores the payoffs of chosen pairs separated by (industry1, industry2)
            pairs_list_dict = {}             # Stores the list of pairs in each (industry1, industry2)

            if len(pair_list[group]) != len(payoffs_list[group]):
                raise Exception("Something wrong when storing pairs and returns in trading script")

            inter_industry_payoffs_curr_group = 0
            within_industry_payoffs_curr_group = 0

            inter_industry_traded_curr_group = 0
            within_industry_traded_curr_group = 0

            inter_industry_identified_curr_group = 0
            within_industry_identified_curr_group = 0

            for pair in range(0, len(pair_list[group])):
                sic_one = int(pair_list[group][pair][7])
                sic_two = int(pair_list[group][pair][8])

                is_identified_group_one = False
                is_identified_group_two = False

                for fama_group, value in groups.items():
                    for sub_group, index in value.items():
                        start = int(index['start'])
                        end = int(index['end'])

                        if start <= sic_one <= end:
                            pair_one_group = fama_group
                            is_identified_group_one = True

                        if start <= sic_two <= end:
                            pair_two_group = fama_group
                            is_identified_group_two = True

                        if is_identified_group_one and is_identified_group_two:
                            break

                    if is_identified_group_one and is_identified_group_two:
                        break

                total_payoffs = sum(x[0] for x in payoffs_list[group][pair])

                # Update gamma Map
                if not is_identified_group_one:
                    pair_one_group = "Unclassified"

                if not is_identified_group_two:
                    pair_two_group = "Unclassified"

                update_results(pair_one_group, pair_two_group, pairs_gamma_dict, pair_list[group][pair][9], True)

                # Update Payoffs Map
                update_results(pair_one_group, pair_two_group, pairs_payoffs_dict, total_payoffs)
                update_results((pair_list[group][pair][0], pair_one_group), (pair_list[group][pair][2], pair_two_group), indiv_pairs_payoffs_dict, total_payoffs)
                update_results((pair_list[group][pair][0], pair_one_group), (pair_list[group][pair][2], pair_two_group), indiv_pairs_gamma_dict, (pair_list[group][pair][9], total_payoffs))

                update_pair_mapping(pair_one_group, pair_two_group, pairs_list_dict, (pair_list[group][pair][0], pair_list[group][pair][2], total_payoffs))

                # Inter-industry
                if pair_one_group != pair_two_group:
                    inter_industry_pairs.append(pair_list[group][pair])
                    inter_industry_identified_curr_group += 1

                    if total_payoffs != 0:
                        inter_industry_payoffs_curr_group += total_payoffs
                        inter_industry_traded_curr_group += 1

                    update_results(pair_one_group, pair_two_group, inter_industry_pairs_dict, total_payoffs)

                # Within industry
                else:
                    within_industry_pairs.append(pair_list[group][pair])
                    within_industry_identified_curr_group += 1

                    if total_payoffs != 0:
                        within_industry_payoffs_curr_group += total_payoffs
                        within_industry_traded_curr_group += 1

            try:
                print("Fully invested return: " + str((inter_industry_payoffs_curr_group + within_industry_payoffs_curr_group)/(inter_industry_traded_curr_group + within_industry_traded_curr_group)))
                if group != "unclassified":
                    returns_list.append((inter_industry_payoffs_curr_group + within_industry_payoffs_curr_group)/(inter_industry_traded_curr_group + within_industry_traded_curr_group))
            except:
                print("Fully invested return: 0.00")

            generate_heat_map(pairs_payoffs_dict, groups)

            # Prints the payoffs of an (industry, industry) pair ranked in descending order
            payoffs_ranking_list = [(k,) + v for k, v in pairs_payoffs_dict.items()]
            sorted_list = sorted(payoffs_ranking_list, key=lambda x: x[2], reverse=True)

            # Stores the pairs that contributed to the top (industry, industry) group
            if len(sorted_list) != 0:
                top_industry_combination = sorted_list[0][0]
                headers = ["Share One", "Share Two", "Payoffs"]
                sorted_pairs = sorted(pairs_list_dict[top_industry_combination], key=lambda x: x[2], reverse=True)

                f = open(model + "pairs_in_top_industry.txt", "a")
                f.write(tabulate(sorted_pairs, headers=headers))
                f.write("\n")
                f.close()

        if model == "baseline":
            average = statistics.mean(returns_list)
            stdev = statistics.stdev(returns_list)

            print("Average: " + str(average))
            print("Standard Deviation: " + str(stdev))
            print("+ 1SD: " + str(average + stdev))
            print("- 1SD: " + str(average - stdev))
            print("Median: " + str(statistics.median(returns_list)))
            print("\n")

        if model == "baseline" or model == "dbscan":
            # Stores the payoffs of the Top 10 pair ranked according to payoffs in descending order
            headers = ["PERMNO and Industries", "Count", "Payoffs"]
            payoffs_ranking_list = [(k,) + v for k, v in indiv_pairs_payoffs_dict.items()]
            sorted_list = sorted(payoffs_ranking_list, key=lambda x: x[2], reverse=True)

            f = open(model + "payoffs.txt", "a")
            f.write(str(year) + "\n")
            f.write(tabulate(sorted_list[:10], headers=headers))

            payoffs = [x[2] for x in sorted_list[:10]]
            f.write("\nAverage: " + str(statistics.mean(payoffs)) + "\n")
            f.close()

            # Stores the payoffs of the Top 10 pair ranked according to gamma in descending order
            headers = ["PERMNO and Industries", "Count", "Gamma, Payoff"]
            payoffs_ranking_gamma_list = [(k,) + v for k, v in indiv_pairs_gamma_dict.items()]
            sorted_list = sorted(payoffs_ranking_gamma_list, key=lambda x: x[2][0], reverse=True)

            f = open(model + "gamma.txt", "a")
            f.write(str(year) + "\n")
            f.write(tabulate(sorted_list[:10], headers=headers))

            gamma_list = [x[2][1] for x in sorted_list[:10]]
            f.write("\nAverage: " + str(statistics.mean(gamma_list)) + "\n")
            f.close()

            for i in range(0, 11):
                if i < len(sorted_list):
                    update_results(sorted_list[i][0][0][0], sorted_list[i][0][1][0], recurring_pairs_dict, 0)

    # Stores the number of times a particular pair is identified in the 17 formation periods
    f = open(model + "recurring.txt", "a")
    recurring_list = [(k,) + v for k, v in recurring_pairs_dict.items()]
    sorted_list = sorted(recurring_list, key=lambda x: x[1], reverse=True)
    f.write(tabulate(sorted_list, headers=headers))
    f.close()


def update_pair_mapping(pair_one, pair_two, pairs_list_dict, pair_info):

    ''' Updates the pairs_list_dict with the new pair

    :param pair_one: First stock in the pair
    :param pair_two: Second stock in the pair
    :param pairs_list_dict: Dictionary that stores the exact pairs of a particular industry combination
    :param pair_info: Permno of the pairs
    :return: None
    '''

    if (pair_one, pair_two) in pairs_list_dict.keys():

        pairs_list_dict[(pair_one, pair_two)].append(pair_info)

    elif (pair_two, pair_one) in pairs_list_dict.keys():
        pairs_list_dict[(pair_two, pair_one)].append(pair_info)

    else:
        pairs_list_dict[(pair_one, pair_two)]= [pair_info]


def update_results(key_one, key_two, results_dict, add_val, calc_average=False):

    ''' Updates the results_dict with new information

    :param key_one: First stock in pair
    :param key_two: Second stock in pair
    :param results_dict: Dictionary to be updated
    :param new_value: new_value to be added to the value of the corresponding key in the results_dict
    :param calc_average: Indicator for whether the new_average has to be calculated when the new_value is added
    :return: None
    '''

    if (key_one, key_two) in results_dict.keys():
        prev_count, prev_val = results_dict[(key_one, key_two)]
        new_count = prev_count + 1

        if calc_average:
            new_val = (prev_val * prev_count + add_val) / new_count
        else:
            new_val = prev_val + add_val
        results_dict[(key_one, key_two)] = (new_count, new_val)

    elif (key_two, key_one) in results_dict.keys():
        prev_count, prev_val = results_dict[(key_two, key_one)]
        new_count = prev_count + 1

        if calc_average:
            new_val = (prev_val * prev_count + add_val) / new_count
        else:
            new_val = prev_val + add_val
        results_dict[(key_two, key_one)] = (new_count, new_val)

    else:
        results_dict[(key_one, key_two)] = (1, add_val)


def generate_heat_map(pairs_payoffs_dict, groups):
    groups_dict = {}   # Map the group to an index
    count = 0

    for group, value in groups.items():
        groups_dict[group] = count
        count += 1

    groups_dict["Unclassified"] = count
    count += 1

    consolidated_result = []

    for i in range(0, count):
        group_result = []
        for j in range(0, count):
            group_result.append(0)
        consolidated_result.append(group_result)

    for pair, stats in pairs_payoffs_dict.items():
        industry_one, industry_two = pair[0], pair[1]
        payoff = stats[1]

        index_one = groups_dict[industry_one]
        index_two = groups_dict[industry_two]

        consolidated_result[index_one][index_two] = payoff
        consolidated_result[index_two][index_one] = payoff

    plt.subplots(figsize=(50, 50))
    plt.tick_params(axis='both', labelsize=30)
    mask = np.zeros_like(consolidated_result, dtype=np.bool)
    mask[np.triu_indices_from(mask)] = True
    mask[np.diag_indices_from(mask)] = False

    ax = sns.heatmap(consolidated_result, mask=mask, xticklabels=list(groups_dict.keys()), yticklabels=list(groups_dict.keys()))
    cbar = ax.collections[0].colorbar
    cbar.ax.tick_params(labelsize=60)
    ax.figure.subplots_adjust(left=0.2, bottom=0.2)
    plt.show()


if __name__ == '__main__':
    pairs_dict, payoffs_per_pair_dict, payoffs_per_day_dict, num_outliers_dict = populate_result.main(models)

    fully_invested_return_list = {}
    identified_pairs_list = {}
    traded_pairs_list = {}

    for model in models:
        print(model)
        analyse_pairs(pairs_dict[model], payoffs_per_pair_dict[model], model)
        print("\n")